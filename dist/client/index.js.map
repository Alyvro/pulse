{"version":3,"sources":["../../src/client/index.ts","../../src/protocol.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport { decode, OpCode } from \"../protocol\";\r\n\r\nexport type ConnectionStatus = \"CONNECTING\" | \"CONNECTED\" | \"DISCONNECTED\";\r\n\r\nexport const usePulse = <T>(channel: string, endpoint = \"/api/pulse\") => {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [status, setStatus] = useState<ConnectionStatus>(\"CONNECTING\");\r\n\r\n  useEffect(() => {\r\n    const es = new EventSource(endpoint);\r\n\r\n    es.onopen = () => {\r\n      // Waiting for handshake\r\n    };\r\n\r\n    es.onmessage = (event) => {\r\n      const packet = decode(event.data);\r\n      if (!packet) return;\r\n\r\n      if (packet.op === OpCode.HANDSHAKE) {\r\n        setStatus(\"CONNECTED\");\r\n      } else if (packet.op === OpCode.DATA && packet.channel === channel) {\r\n        setData(packet.payload as any);\r\n      }\r\n    };\r\n\r\n    es.onerror = () => {\r\n      setStatus(\"DISCONNECTED\");\r\n      es.close();\r\n    };\r\n\r\n    return () => {\r\n      es.close();\r\n    };\r\n  }, [channel, endpoint]);\r\n\r\n  return { data, status };\r\n};\r\n","import { nanoid } from \"nanoid\";\r\n\r\nexport const PROTOCOL_HEAD = \"APWP\";\r\nexport const SEPARATOR = \"|\";\r\n\r\nexport enum OpCode {\r\n  HANDSHAKE = 1,\r\n  PING = 2,\r\n  DATA = 3,\r\n  ERROR = 9,\r\n}\r\n\r\nexport interface PulsePacket<T = any> {\r\n  id: string;\r\n  op: OpCode;\r\n  channel: string;\r\n  payload: T;\r\n  timestamp: number;\r\n}\r\n\r\nconst generateChecksum = (data: string): string => {\r\n  let a = 1,\r\n    b = 0;\r\n  for (let i = 0; i < data.length; i++) {\r\n    a = (a + data.charCodeAt(i)) % 65521;\r\n    b = (b + a) % 65521;\r\n  }\r\n  return ((b << 16) | a).toString(16);\r\n};\r\n\r\nexport const encode = (op: OpCode, channel: string, data: any): string => {\r\n  const id = nanoid(6);\r\n  const ts = Date.now().toString(36);\r\n\r\n  const payloadStr = JSON.stringify(data);\r\n  const encodedPayload =\r\n    typeof window === \"undefined\"\r\n      ? Buffer.from(payloadStr).toString(\"base64\")\r\n      : btoa(payloadStr);\r\n\r\n  const body = `${PROTOCOL_HEAD}${SEPARATOR}1${SEPARATOR}${op}${SEPARATOR}${id}${SEPARATOR}${ts}${SEPARATOR}${channel}${SEPARATOR}${encodedPayload}`;\r\n  const checksum = generateChecksum(body);\r\n\r\n  return `${body}${SEPARATOR}${checksum}`;\r\n};\r\n\r\nexport const decode = <T>(raw: string): PulsePacket<T> | null => {\r\n  if (!raw.startsWith(PROTOCOL_HEAD)) return null;\r\n\r\n  const parts = raw.split(SEPARATOR);\r\n  if (parts.length !== 8) return null;\r\n\r\n  const [_head, _ver, op, id, ts, channel, payloadBase64, receivedChecksum] =\r\n    parts;\r\n\r\n  const reconstructBody = parts.slice(0, 7).join(SEPARATOR);\r\n  const calculatedChecksum = generateChecksum(reconstructBody);\r\n\r\n  if (receivedChecksum !== calculatedChecksum) return null;\r\n\r\n  try {\r\n    const payloadStr =\r\n      typeof window === \"undefined\"\r\n        ? Buffer.from(payloadBase64, \"base64\").toString()\r\n        : atob(payloadBase64);\r\n\r\n    return {\r\n      id,\r\n      op: parseInt(op) as OpCode,\r\n      channel,\r\n      payload: JSON.parse(payloadStr),\r\n      timestamp: parseInt(ts, 36),\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n"],"mappings":"AAAA,OAAS,aAAAA,EAAW,YAAAC,MAAgB,QCApC,OAAS,UAAAC,MAAc,SAEhB,IAAMC,EAAgB,OAChBC,EAAY,IAiBzB,IAAMC,EAAoBC,GAAyB,CACjD,IAAIC,EAAI,EACNC,EAAI,EACN,QAASC,EAAI,EAAGA,EAAIH,EAAK,OAAQG,IAC/BF,GAAKA,EAAID,EAAK,WAAWG,CAAC,GAAK,MAC/BD,GAAKA,EAAID,GAAK,MAEhB,OAASC,GAAK,GAAMD,GAAG,SAAS,EAAE,CACpC,EAkBO,IAAMG,EAAaC,GAAuC,CAC/D,GAAI,CAACA,EAAI,WAAWC,CAAa,EAAG,OAAO,KAE3C,IAAMC,EAAQF,EAAI,MAAMG,CAAS,EACjC,GAAID,EAAM,SAAW,EAAG,OAAO,KAE/B,GAAM,CAACE,EAAOC,EAAMC,EAAIC,EAAIC,EAAIC,EAASC,EAAeC,CAAgB,EACtET,EAEIU,EAAkBV,EAAM,MAAM,EAAG,CAAC,EAAE,KAAKC,CAAS,EAClDU,EAAqBC,EAAiBF,CAAe,EAE3D,GAAID,IAAqBE,EAAoB,OAAO,KAEpD,GAAI,CACF,IAAME,EACJ,OAAO,OAAW,IACd,OAAO,KAAKL,EAAe,QAAQ,EAAE,SAAS,EAC9C,KAAKA,CAAa,EAExB,MAAO,CACL,GAAAH,EACA,GAAI,SAASD,CAAE,EACf,QAAAG,EACA,QAAS,KAAK,MAAMM,CAAU,EAC9B,UAAW,SAASP,EAAI,EAAE,CAC5B,CACF,MAAQ,CACN,OAAO,IACT,CACF,EDvEO,IAAMQ,EAAW,CAAIC,EAAiBC,EAAW,eAAiB,CACvE,GAAM,CAACC,EAAMC,CAAO,EAAIC,EAAmB,IAAI,EACzC,CAACC,EAAQC,CAAS,EAAIF,EAA2B,YAAY,EAEnE,OAAAG,EAAU,IAAM,CACd,IAAMC,EAAK,IAAI,YAAYP,CAAQ,EAEnC,OAAAO,EAAG,OAAS,IAAM,CAElB,EAEAA,EAAG,UAAaC,GAAU,CACxB,IAAMC,EAASC,EAAOF,EAAM,IAAI,EAC3BC,IAEDA,EAAO,KAAO,EAChBJ,EAAU,WAAW,EACZI,EAAO,KAAO,GAAeA,EAAO,UAAYV,GACzDG,EAAQO,EAAO,OAAc,EAEjC,EAEAF,EAAG,QAAU,IAAM,CACjBF,EAAU,cAAc,EACxBE,EAAG,MAAM,CACX,EAEO,IAAM,CACXA,EAAG,MAAM,CACX,CACF,EAAG,CAACR,EAASC,CAAQ,CAAC,EAEf,CAAE,KAAAC,EAAM,OAAAG,CAAO,CACxB","names":["useEffect","useState","nanoid","PROTOCOL_HEAD","SEPARATOR","generateChecksum","data","a","b","i","decode","raw","PROTOCOL_HEAD","parts","SEPARATOR","_head","_ver","op","id","ts","channel","payloadBase64","receivedChecksum","reconstructBody","calculatedChecksum","generateChecksum","payloadStr","usePulse","channel","endpoint","data","setData","useState","status","setStatus","useEffect","es","event","packet","decode"]}