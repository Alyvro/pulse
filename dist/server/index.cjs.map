{"version":3,"sources":["../../src/server/index.ts","../../src/protocol.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { EventEmitter } from \"node:events\";\r\nimport { encode, OpCode } from \"../protocol\";\r\n\r\nclass PulseServer {\r\n  private bus = new EventEmitter();\r\n\r\n  constructor() {\r\n    this.bus.setMaxListeners(0);\r\n  }\r\n\r\n  public emit(channel: string, data: any) {\r\n    this.bus.emit(\"broadcast\", { channel, data });\r\n  }\r\n\r\n  public Handler() {\r\n    return (req: NextRequest) => {\r\n      const encoder = new TextEncoder();\r\n\r\n      const stream = new ReadableStream({\r\n        start: async (controller) => {\r\n          const sendFrame = (op: OpCode, ch: string, body: any) => {\r\n            const packet = encode(op, ch, body);\r\n            controller.enqueue(encoder.encode(`data: ${packet}\\n\\n`));\r\n          };\r\n\r\n          sendFrame(OpCode.HANDSHAKE, \"system\", { status: \"ok\" });\r\n\r\n          const onMessage = ({ channel, data }: any) => {\r\n            sendFrame(OpCode.DATA, channel, data);\r\n          };\r\n\r\n          this.bus.on(\"broadcast\", onMessage);\r\n\r\n          const heartbeat = setInterval(() => {\r\n            sendFrame(OpCode.PING, \"system\", {});\r\n          }, 15000);\r\n\r\n          req.signal.addEventListener(\"abort\", () => {\r\n            this.bus.off(\"broadcast\", onMessage);\r\n            clearInterval(heartbeat);\r\n            controller.close();\r\n          });\r\n        },\r\n      });\r\n\r\n      return new NextResponse(stream, {\r\n        headers: {\r\n          \"Content-Type\": \"text/event-stream\",\r\n          \"Cache-Control\": \"no-cache\",\r\n          Connection: \"keep-alive\",\r\n        },\r\n      });\r\n    };\r\n  }\r\n}\r\n\r\nexport const pulse = new PulseServer();\r\n","import { nanoid } from \"nanoid\";\r\n\r\nexport const PROTOCOL_HEAD = \"APWP\";\r\nexport const SEPARATOR = \"|\";\r\n\r\nexport enum OpCode {\r\n  HANDSHAKE = 1,\r\n  PING = 2,\r\n  DATA = 3,\r\n  ERROR = 9,\r\n}\r\n\r\nexport interface PulsePacket<T = any> {\r\n  id: string;\r\n  op: OpCode;\r\n  channel: string;\r\n  payload: T;\r\n  timestamp: number;\r\n}\r\n\r\nconst generateChecksum = (data: string): string => {\r\n  let a = 1,\r\n    b = 0;\r\n  for (let i = 0; i < data.length; i++) {\r\n    a = (a + data.charCodeAt(i)) % 65521;\r\n    b = (b + a) % 65521;\r\n  }\r\n  return ((b << 16) | a).toString(16);\r\n};\r\n\r\nexport const encode = (op: OpCode, channel: string, data: any): string => {\r\n  const id = nanoid(6);\r\n  const ts = Date.now().toString(36);\r\n\r\n  const payloadStr = JSON.stringify(data);\r\n  const encodedPayload =\r\n    typeof window === \"undefined\"\r\n      ? Buffer.from(payloadStr).toString(\"base64\")\r\n      : btoa(payloadStr);\r\n\r\n  const body = `${PROTOCOL_HEAD}${SEPARATOR}1${SEPARATOR}${op}${SEPARATOR}${id}${SEPARATOR}${ts}${SEPARATOR}${channel}${SEPARATOR}${encodedPayload}`;\r\n  const checksum = generateChecksum(body);\r\n\r\n  return `${body}${SEPARATOR}${checksum}`;\r\n};\r\n\r\nexport const decode = <T>(raw: string): PulsePacket<T> | null => {\r\n  if (!raw.startsWith(PROTOCOL_HEAD)) return null;\r\n\r\n  const parts = raw.split(SEPARATOR);\r\n  if (parts.length !== 8) return null;\r\n\r\n  const [_head, _ver, op, id, ts, channel, payloadBase64, receivedChecksum] =\r\n    parts;\r\n\r\n  const reconstructBody = parts.slice(0, 7).join(SEPARATOR);\r\n  const calculatedChecksum = generateChecksum(reconstructBody);\r\n\r\n  if (receivedChecksum !== calculatedChecksum) return null;\r\n\r\n  try {\r\n    const payloadStr =\r\n      typeof window === \"undefined\"\r\n        ? Buffer.from(payloadBase64, \"base64\").toString()\r\n        : atob(payloadBase64);\r\n\r\n    return {\r\n      id,\r\n      op: parseInt(op) as OpCode,\r\n      channel,\r\n      payload: JSON.parse(payloadStr),\r\n      timestamp: parseInt(ts, 36),\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,WAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA0C,uBAC1CC,EAA6B,kBCD7B,IAAAC,EAAuB,kBAEVC,EAAgB,OAChBC,EAAY,IAiBzB,IAAMC,EAAoBC,GAAyB,CACjD,IAAIC,EAAI,EACNC,EAAI,EACN,QAASC,EAAI,EAAGA,EAAIH,EAAK,OAAQG,IAC/BF,GAAKA,EAAID,EAAK,WAAWG,CAAC,GAAK,MAC/BD,GAAKA,EAAID,GAAK,MAEhB,OAASC,GAAK,GAAMD,GAAG,SAAS,EAAE,CACpC,EAEaG,EAAS,CAACC,EAAYC,EAAiBN,IAAsB,CACxE,IAAMO,KAAK,UAAO,CAAC,EACbC,EAAK,KAAK,IAAI,EAAE,SAAS,EAAE,EAE3BC,EAAa,KAAK,UAAUT,CAAI,EAChCU,EACJ,OAAO,OAAW,IACd,OAAO,KAAKD,CAAU,EAAE,SAAS,QAAQ,EACzC,KAAKA,CAAU,EAEfE,EAAO,GAAGC,CAAa,GAAGC,CAAS,IAAIA,CAAS,GAAGR,CAAE,GAAGQ,CAAS,GAAGN,CAAE,GAAGM,CAAS,GAAGL,CAAE,GAAGK,CAAS,GAAGP,CAAO,GAAGO,CAAS,GAAGH,CAAc,GAC1II,EAAWf,EAAiBY,CAAI,EAEtC,MAAO,GAAGA,CAAI,GAAGE,CAAS,GAAGC,CAAQ,EACvC,EDxCA,IAAMC,EAAN,KAAkB,CAGhB,aAAc,CAFd,KAAQ,IAAM,IAAI,eAGhB,KAAK,IAAI,gBAAgB,CAAC,CAC5B,CAEO,KAAKC,EAAiBC,EAAW,CACtC,KAAK,IAAI,KAAK,YAAa,CAAE,QAAAD,EAAS,KAAAC,CAAK,CAAC,CAC9C,CAEO,SAAU,CACf,OAAQC,GAAqB,CAC3B,IAAMC,EAAU,IAAI,YAEdC,EAAS,IAAI,eAAe,CAChC,MAAO,MAAOC,GAAe,CAC3B,IAAMC,EAAY,CAACC,EAAYC,EAAYC,IAAc,CACvD,IAAMC,EAASC,EAAOJ,EAAIC,EAAIC,CAAI,EAClCJ,EAAW,QAAQF,EAAQ,OAAO,SAASO,CAAM;AAAA;AAAA,CAAM,CAAC,CAC1D,EAEAJ,IAA4B,SAAU,CAAE,OAAQ,IAAK,CAAC,EAEtD,IAAMM,EAAY,CAAC,CAAE,QAAAZ,EAAS,KAAAC,CAAK,IAAW,CAC5CK,IAAuBN,EAASC,CAAI,CACtC,EAEA,KAAK,IAAI,GAAG,YAAaW,CAAS,EAElC,IAAMC,EAAY,YAAY,IAAM,CAClCP,IAAuB,SAAU,CAAC,CAAC,CACrC,EAAG,IAAK,EAERJ,EAAI,OAAO,iBAAiB,QAAS,IAAM,CACzC,KAAK,IAAI,IAAI,YAAaU,CAAS,EACnC,cAAcC,CAAS,EACvBR,EAAW,MAAM,CACnB,CAAC,CACH,CACF,CAAC,EAED,OAAO,IAAI,eAAaD,EAAQ,CAC9B,QAAS,CACP,eAAgB,oBAChB,gBAAiB,WACjB,WAAY,YACd,CACF,CAAC,CACH,CACF,CACF,EAEaU,EAAQ,IAAIf","names":["server_exports","__export","pulse","__toCommonJS","import_server","import_node_events","import_nanoid","PROTOCOL_HEAD","SEPARATOR","generateChecksum","data","a","b","i","encode","op","channel","id","ts","payloadStr","encodedPayload","body","PROTOCOL_HEAD","SEPARATOR","checksum","PulseServer","channel","data","req","encoder","stream","controller","sendFrame","op","ch","body","packet","encode","onMessage","heartbeat","pulse"]}